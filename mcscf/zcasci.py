# Author: Xubo Wang <wangxubo0201@outlook.com>
# Date: 2023/11/28

import sys
from functools import reduce
import numpy
from pyscf.lib import logger
from pyscf import gto, scf, ao2mo, fci, x2c, __config__, lib
from pyscf.mcscf import addons
from pyscf.ao2mo import nrr_outcore
import h5py
from . import zcasbase
from . import zmc_ao2mo
from socutils.tools import fcidump_rel


def h1e_for_cas(casci, mo_coeff=None, ncas=None, ncore=None):
    '''CAS sapce one-electron hamiltonian

    Args:
        casci : a CASSCF/CASCI object or RHF object

    Returns:
        A tuple, the first is the effective one-electron hamiltonian defined in CAS space,
        the second is the electronic energy from core.
    '''
    if mo_coeff is None: mo_coeff = casci.mo_coeff
    if ncas is None: ncas = casci.ncas
    if ncore is None: ncore = casci.ncore
    mo_core = mo_coeff[:, :ncore]
    mo_cas = mo_coeff[:, ncore:ncore + ncas]

    hcore = casci.get_hcore()
    energy_core = casci.energy_nuc()
    if mo_core.size == 0:
        corevhf = 0
    else:
        core_dm = numpy.dot(mo_core, mo_core.T.conj())
        corevhf = casci.get_veff(casci.mol, core_dm)

        #j, k = casci._scf.get_jk(casci.mol, core_dm)
        energy_core += numpy.einsum('ij,ji', core_dm, hcore)
        energy_core += numpy.einsum('ij,ji', core_dm, corevhf) * .5
    h1eff = reduce(numpy.dot, (mo_cas.T.conj(), hcore + corevhf, mo_cas))
    return h1eff, energy_core


def get_fock(mc, mo_coeff=None, ci=None, eris=None, casdm1=None, verbose=None):
    r'''
    Effective one-electron Fock matrix in AO representation
    f = \sum_{pq} E_{pq} F_{pq}
    F_{pq} = h_{pq} + \sum_{rs} [(pq|rs)-(ps|rq)] DM_{sr}

    Ref.
    Theor. Chim. Acta., 91, 31
    Chem. Phys. 48, 157

    For state-average CASCI/CASSCF object, the effective fock matrix is based
    on the state-average density matrix.  To obtain Fock matrix of a specific
    state in the state-average calculations, you can pass "casdm1" of the
    specific state to this function.

    Args:
        mc: a CASSCF/CASCI object or RHF object

    Kwargs:
        mo_coeff (ndarray): orbitals that span the core, active and external
            space.
        ci (ndarray): CI coefficients (or objects to represent the CI
            wavefunctions in DMRG/QMC-MCSCF calculations).
        eris: Integrals for the MCSCF object. Input this object to reduce the
            overhead of computing integrals. It can be generated by
            :func:`mc.ao2mo` method.
        casdm1 (ndarray): 1-particle density matrix in active space. Without
            input casdm1, the density matrix is computed with the input ci
            coefficients/object. If neither ci nor casdm1 were given, density
            matrix is computed by :func:`mc.fcisolver.make_rdm1` method. For
            state-average CASCI/CASCF calculation, this results in the
            effective Fock matrix based on the state-average density matrix.
            To obtain the effective Fock matrix for one particular state, you
            can assign the density matrix of that state to the kwarg casdm1.

    Returns:
        Fock matrix
    '''

    if ci is None: ci = mc.ci
    if mo_coeff is None: mo_coeff = mc.mo_coeff
    nmo = mo_coeff.shape[1]
    ncore = mc.ncore
    ncas = mc.ncas
    nocc = ncore + ncas
    nelecas = mc.nelecas

    if casdm1 is None:
        casdm1 = mc.fcisolver.make_rdm1(ci, ncas, nelecas)
    '''
    # this block needs to be revised.
    if getattr(eris, 'ppaa', None) is not None:
        vj = numpy.empty((nmo,nmo))
        vk = numpy.empty((nmo,nmo))
        for i in range(nmo):
            vj[i] = numpy.einsum('ij,qij->q', casdm1, eris.ppaa[i])
            vk[i] = numpy.einsum('ij,iqj->q', casdm1, eris.papa[i])
        mo_inv = numpy.dot(mo_coeff.T, mc._scf.get_ovlp())
        fock =(mc.get_hcore()
             + reduce(numpy.dot, (mo_inv.T, eris.vhf_c+vj-vk*.5, mo_inv)))
    else:
    '''
    dm_core = numpy.dot(mo_coeff[:, :ncore], mo_coeff[:, :ncore].T.conj())
    mocas = mo_coeff[:, ncore:nocc]
    dm = dm_core + reduce(numpy.dot, (mocas, casdm1, mocas.T.conj()))
    vj, vk = mc._scf.get_jk(mc.mol, dm)
    fock = mc.get_hcore() + vj - vk * .5
    return fock


def kernel(casci, mo_coeff=None, ci0=None, verbose=logger.NOTE):
    '''CASCI solver
    '''
    if mo_coeff is None: mo_coeff = casci.mo_coeff
    log = logger.new_logger(casci, verbose)
    t0 = (logger.process_clock(), logger.perf_counter())
    log.debug('Start CASCI')

    ncas = casci.ncas
    nelecas = casci.nelecas

    # 2e
    eri_cas = casci.get_h2eff(mo_coeff)
    t1 = log.timer('integral transformation to CAS space', *t0)

    # 1e
    h1eff, energy_core = casci.get_h1eff(mo_coeff)
    log.debug('core energy = %.15g', energy_core)
    #t1 = log.timer('effective h1e in CAS space', *t1)

    if h1eff.shape[0] != ncas:
        raise RuntimeError('Active space size error. nmo=%d ncore=%d ncas=%d' % (mo_coeff.shape[1], casci.ncore, ncas))

    # FCI
    fcidump_rel.from_integrals('FCIDUMP', h1eff, eri_cas.reshape(ncas*ncas, ncas*ncas), ncas, nelecas, energy_core.real)
    max_memory = max(4000, casci.max_memory - lib.current_memory()[0])
    e_tot, fcivec = casci.fcisolver.kernel(h1eff, eri_cas.reshape(ncas, ncas, ncas, ncas), ncas, nelecas,
                                           ci0=ci0, verbose=log, max_memory=max_memory, ecore=energy_core)
    print(e_tot)
    #if isinstance(e_tot, list):
    #    e_tot = numpy.average(e_tot)
    t1 = log.timer('FCI solver', *t1)
    e_cas = e_tot.real - energy_core.real
    if not isinstance(e_cas, (float, numpy.number)):
        e_cas = e_cas.mean()
        e_tot = e_tot.mean()
    return e_tot.real, e_cas.real, fcivec


class CASCI(zcasbase.CASBase):
    '''CASCI

    Args:
        mf_or_mol : SCF object or Mole object
            SCF or Mole to define the problem size.
        ncas : int
            Number of active orbitals.
        nelecas : int 
            Number of electrons in active space.

    Kwargs:
        ncore : int
            Number of core orbitals. If not presented, this
            parameter can be automatically determined.

    Attributes:
        verbose : int
            Print level.  Default value equals to :class:`Mole.verbose`.
        max_memory : float or int
            Allowed memory in MB.  Default value equals to :class:`Mole.max_memory`.
        ncas : int
            Active space size.
        nelecas : int
            Active electrons
        ncore : int 
            Core electron number.
        natorb : bool
            Whether to transform natural orbital in active space.  Be cautious
            of this parameter when CASCI/CASSCF are combined with DMRG solver
            or selected CI solver because DMRG and selected CI are not invariant
            to the rotation in active space.
            False by default.
        canonicalization : bool
            Whether to canonicalize orbitals. Note that canonicalization does
            not change the orbitals in active space by default. It only
            diagonalizes core and external space of the general Fock matirx.
            To get the natural orbitals in active space, attribute natorb
            need to be enabled.
            True by default.
        sorting_mo_energy : bool
            Whether to sort the orbitals based on the diagonal elements of the
            general Fock matrix.  Default is False.
        fcisolver : an instance of :class:`FCISolver`
            The pyscf.fci module provides several FCISolver for different scenario.  Generally,
            fci.direct_spin1.FCISolver can be used for all RHF-CASSCF.  However, a proper FCISolver
            can provide better performance and better numerical stability.  One can either use
            :func:`fci.solver` function to pick the FCISolver by the program or manually assigen
            the FCISolver to this attribute, e.g.

            >>> from pyscf import fci
            >>> mc = mcscf.CASSCF(mf, 4, 4)
            >>> mc.fcisolver = fci.solver(mol, singlet=True)
            >>> mc.fcisolver = fci.direct_spin1.FCISolver(mol)

            You can control FCISolver by setting e.g.::

                >>> mc.fcisolver.max_cycle = 30
                >>> mc.fcisolver.conv_tol = 1e-7

            For more details of the parameter for FCISolver, See :mod:`fci`.

    Saved results

        e_tot : float
            Total MCSCF energy (electronic energy plus nuclear repulsion)
        e_cas : float
            CAS space FCI energy
        ci : ndarray
            CAS space FCI coefficients
        mo_coeff : ndarray
            When canonicalization is specified, the orbitals are canonical
            orbitals which make the general Fock matrix (Fock operator on top
            of MCSCF 1-particle density matrix) diagonalized within each
            subspace (core, active, external).  If natorb (natural orbitals in
            active space) is specified, the active segment of the mo_coeff is
            natural orbitls.
        mo_energy : ndarray
            Diagonal elements of general Fock matrix (in mo_coeff
            representation).

    Examples:

    >>> from pyscf import gto, scf, mcscf
    >>> mol = gto.M(atom='N 0 0 0; N 0 0 1', basis='ccpvdz', verbose=0)
    >>> mf = scf.RHF(mol)
    >>> mf.scf()
    >>> mc = mcscf.CASCI(mf, 6, 6)
    >>> mc.kernel()[0]
    -108.980200816243354
    '''

    #natorb = getattr(__config__, 'zmcscf_gzcasci_CASCI_natorb', False)
    #canonicalization = getattr(__config__, 'zmcscf_gzcasci_CASCI_canonicalization', False)
    sorting_mo_energy = getattr(__config__, 'zmcscf_gzcasci_CASCI_sorting_mo_energy', False)

    #     def __init__(self, mf_or_mol, ncas, nelecas, ncore=None):
    #         if isinstance(mf_or_mol, gto.Mole):
    #             mf = scf.X2C(mf_or_mol)
    #         elif isinstance(mf_or_mol, x2c.x2c.SCF) or isinstance(mf_or_mol, scf.ghf.GHF):
    #             mf = mf_or_mol
    #         else:
    #             print("we need the mean field object to be of GHF type")
    #
    #         mol = mf.mol
    #         self.mol = mol
    #         self._scf = mf
    #         self.verbose = mol.verbose
    #         self.stdout = mol.stdout
    #         self.max_memory = mf.max_memory
    #         self.ncas = ncas
    #         if isinstance(nelecas, (int, numpy.integer)):
    #             nelecb = (nelecas-mol.spin)//2
    #             neleca = nelecas - nelecb
    #             self.nelecas = (neleca, nelecb)
    #         else:
    #             self.nelecas = (nelecas[0],nelecas[1])
    #         self.ncore = ncore
    #         self.fcisolver = fci.fci_dhf_slow.FCISolver(mol)
    # # CI solver parameters are set in fcisolver object
    #         self.fcisolver.max_cycle = getattr(__config__,
    #                                            'mcscf_casci_CASCI_fcisolver_max_cycle', 200)
    #         self.fcisolver.conv_tol = getattr(__config__,
    #                                           'mcscf_casci_CASCI_fcisolver_conv_tol', 1e-8)
    #
    # ##################################################
    # # don't modify the following attributes, they are not input options
    #         self.e_tot = 0
    #         self.e_cas = None
    #         self.ci = None
    #         self.mo_coeff = (1.+0j)*mf.mo_coeff #complex orbitals
    #         self.mo_energy = mf.mo_energy
    #         self.converged = False
    #
    #         keys = set(('natorb', 'canonicalization', 'sorting_mo_energy'))
    #         self._keys = set(self.__dict__.keys()).union(keys)

    #    def dump_flags(self, verbose=None):
    #        log = logger.new_logger(self, verbose)
    #        log.info('')
    #        log.info('******** CASCI flags ********')
    #        ncore = self.ncore
    #        ncas = self.ncas
    #        nvir = self.mo_coeff.shape[1] - ncore - ncas
    #        log.info('CAS (%de+%de, %do), ncore = %d, nvir = %d', \
    #                 self.nelecas[0], self.nelecas[1], ncas, ncore, nvir)
    #        assert(self.ncas > 0)
    #        #log.info('natorb = %s', self.natorb)
    #        #log.info('canonicalization = %s', self.canonicalization)
    #        log.info('sorting_mo_energy = %s', self.sorting_mo_energy)
    #        log.info('max_memory %d (MB)', self.max_memory)
    #        if getattr(self.fcisolver, 'dump_flags', None):
    #            self.fcisolver.dump_flags(log.verbose)
    #        if self.mo_coeff is None:
    #            log.error('Orbitals for CASCI are not specified. The relevant SCF '
    #                      'object may not be initialized.')

    def reset(self, mol=None):
        if mol is not None:
            self.mol = mol
            self.fcisolver.mol = mol
        self._scf.reset(mol)
        return self

    def energy_nuc(self):
        return self._scf.energy_nuc()

    def get_hcore(self, mol=None):
        return self._scf.get_hcore(mol)

    def get_veff(self, mol=None, dm=None, hermi=1):
        if mol is None: mol = self.mol
        if dm is None:
            mocore = self.mo_coeff[:, :self.ncore]
            dm = numpy.dot(mocore, mocore.T.conj())

        j, k = self._scf.get_jk(mol, dm)
        return j - k

    def _eig(self, h, *args):
        return scf.hf.eig(h, None)

    def get_h2cas(self, mo_coeff=None):
        '''Computing active space two-particle Hamiltonian.

        Note It is different to get_h2eff when df.approx_hessian is applied,
        in which get_h2eff function returns the DF integrals while get_h2cas
        returns the regular 2-electron integrals.
        '''
        return self.ao2mo(mo_coeff)

    def get_h2eff(self, mo_coeff=None):
        '''Computing active space two-particle Hamiltonian.

        Note It is different to get_h2cas when df.approx_hessian is applied.
        in which get_h2eff function returns the DF integrals while get_h2cas
        returns the regular 2-electron integrals.
        '''
        return self.ao2mo(mo_coeff)

    ####THIS SHOULD BE CHECKED###
    def ao2mo(self, mo_coeff=None, level=1):
        ncore = self.ncore
        ncas = self.ncas
        nocc = ncore + ncas
        nao = self.mo_coeff.shape[0] // 2
        if mo_coeff is None:
            ncore = self.ncore
            mo_coeff = self.mo_coeff

        eri_cas1 = nrr_outcore.full_iofree(self.mol, mo_coeff[:, ncore:nocc], motype='j-spinor', verbose=5)
        eri_cas = ao2mo.kernel(self.mol, mo_coeff[:, ncore:nocc], intor='int2e_spinor', verbose=5)
        from numpy.linalg import norm
        return eri_cas

    get_h1cas = h1e_for_cas = h1e_for_cas

    def get_h1eff(self, mo_coeff=None, ncas=None, ncore=None):
        return self.h1e_for_cas(mo_coeff, ncas, ncore)

    get_h1eff.__doc__ = h1e_for_cas.__doc__

    def casci(self, mo_coeff=None, ci0=None, verbose=None):
        return self.kernel(mo_coeff, ci0, verbose)

    def kernel(self, mo_coeff=None, ci0=None, verbose=None):
        '''
        Returns:
            Five elements, they are
            total energy,
            active space CI energy,
            the active space FCI wavefunction coefficients or DMRG wavefunction ID,
            the MCSCF canonical orbital coefficients,

        They are attributes of mcscf object, which can be accessed by
        .e_tot, .e_cas, .ci, .mo_coeff, .mo_energy
        '''
        if mo_coeff is None:
            mo_coeff = self.mo_coeff
        else:
            self.mo_coeff = mo_coeff
        if ci0 is None:
            ci0 = self.ci
        log = logger.new_logger(self, verbose)

        if self.verbose >= logger.WARN:
            self.check_sanity()
        #self.dump_flags(log)

        self.e_tot, self.e_cas, self.ci = \
                kernel(self, mo_coeff, ci0=ci0, verbose=verbose)

        #        if self.canonicalization:
        #            self.canonicalize_(mo_coeff, self.ci,
        #                               sort=self.sorting_mo_energy,
        #                               cas_natorb=self.natorb, verbose=log)

        if getattr(self.fcisolver, 'converged', None) is not None:
            self.converged = numpy.all(self.fcisolver.converged)
            if self.converged:
                log.info('CASCI converged')
            else:
                log.info('CASCI not converged')
        else:
            self.converged = True
        #self._finalize()
        return self.e_tot, self.e_cas, self.ci

    def _finalize(self):
        log = logger.Logger(self.stdout, self.verbose)
        if isinstance(self.e_cas, (float, numpy.number)):
            log.note('CASCI E = %.15g  E(CI) = %.15g', self.e_tot, self.e_cas)
        else:
            for i, e in enumerate(self.e_cas):
                log.note('CASCI state %d  E = %.15g  E(CI) = %.15g', i, self.e_tot[i], e)
        return self

    def get_fock(self, mo_coeff=None, ci=None, eris=None, casdm1=None, verbose=None):
        return get_fock(self, mo_coeff, ci, eris, casdm1, verbose)

    @lib.with_doc(addons.sort_mo.__doc__)
    def sort_mo(self, caslst, mo_coeff=None, base=1):
        if mo_coeff is None: mo_coeff = self.mo_coeff
        return addons.sort_mo(self, mo_coeff, caslst, base)

    @lib.with_doc(addons.state_average.__doc__)
    def state_average_(self, weights=(0.5, 0.5)):
        addons.state_average_(self, weights)
        return self

    @lib.with_doc(addons.state_average.__doc__)
    def state_average(self, weights=(0.5, 0.5)):
        return addons.state_average(self, weights)

    @lib.with_doc(addons.state_specific_.__doc__)
    def state_specific_(self, state=1):
        addons.state_specific(self, state)
        return self

    def make_rdm1(self, mo_coeff=None, ci=None, ncas=None, nelecas=None, ncore=None, **kwargs):
        '''One-particle density matrix in AO representation
        '''
        if mo_coeff is None: mo_coeff = self.mo_coeff
        if ci is None: ci = self.ci
        if ncas is None: ncas = self.ncas
        if nelecas is None: nelecas = self.nelecas
        if ncore is None: ncore = self.ncore

        casdm1 = self.fcisolver.make_rdm1(ci, ncas, nelecas)
        mocore = mo_coeff[:, :ncore]
        mocas = mo_coeff[:, ncore:ncore + ncas]
        dm1 = numpy.dot(mocore, mocore.T.conj())
        dm1 = dm1 + reduce(numpy.dot, (mocas, casdm1, mocas.T.conj()))
        return dm1


if __name__ == '__main__':
    from pyscf import mcscf
    mol = gto.Mole()
    mol.verbose = 4
    mol.output = None  #"out_h2o"
    mol.atom = [
        ['O', (0., 0., 0.)],
        ['H', (0., -0.757, 0.587)],
        ['H', (0., 0.757, 0.587)],
    ]

    mol.basis = {
        'H': 'sto-3g',
        'O': 'sto-3g',
    }
    mol.build()

    m = scf.X2C(mol)
    ehf = m.kernel()

    mc = CASCI(m, 4, 4)
    from pyscf.shciscf import shci
    mc.fcisolver = shci.SHCI(mol, maxM=1.e-3)
    mc.natorb = 1
    emc = mc.kernel()[0]
    print(ehf, emc, emc - ehf)
    #-75.9577817425 -75.9624554777 -0.00467373522233
    print(emc + 75.9624554777)
